/****************************************
*	Defusing Game Mode					*
*	Author:		steeffeen				*
*	Contact:	mail@steeffeen.com		*
****************************************/

#Extends "Modes/ShootMania/ModeBase.Script.txt"


/****************************************
	INCLUDES
****************************************/

#Include "MathLib" as MathLib
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM


/****************************************
	CONSTANTS
****************************************/

#Const	Version	"0.03 (29.10.2013)"


/****************************************
	GLOBALES
****************************************/

declare Ident[][Integer]	G_ClanSpawnIds;		// Ids of each clans spawn blocks
declare Ident[]				G_BombPoleIds;		// Ids of the bomb spots
declare Integer				G_AttackingTeam;	// Clan number of the currently attacking team


/****************************************
	LABELS
****************************************/

***StartServer***
***
// Enable rounds in modebase
MB_UseSectionRound = True;

// Set mode options
UseClans = True;

// Add bots
Users_SetNbFakeUsers(2, 2);
***

***StartMap***
***
// Prepare map
PrepareMap();

// Begin match
Score::MatchBegin();
***

***StartRound***
***
// Prepare next round
PrepareRound();

// Prepare scores
Score::RoundBegin();

// Set the begin of the round
Mode::Synchro_DoBarrier();
StartTime = Now + 3500;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***PlayLoop***
***
// Manage players
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			
			if (Player.RequestsSpectate) {
				// The player wants to spectate - Do nothing
				continue;
			}
			
			// Spawn the player
			MySpawnPlayer(Player);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			
			if (Player.RequestsSpectate) {
				// The player wants to spectate
				UnspawnPlayer(Player);
				continue;
			}
			
			if (Player.RequestedClan != Player.CurrentClan) {
				// The player wants to change its team
				UnspawnPlayer(Player);
				continue;
			}
		}
	}
}

// Manage events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
		
			if (Event.Shooter == Event.Victim) {
				// Self hit
				Discard(Event);
				continue;
			}
			
			if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
				// Team hit
				Discard(Event);
				continue;
			}
			
			// Opponent hit
			
			// Calculate points
			declare Points = Event.Damage / 100;
			
			// Grant points for the shooter
			Score::AddPoints(Event.Shooter, Points);
			
			// Set the amount of + displayed for the shooter
			Event.ShooterPoints = Points;
			
			// Pass on event
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			// Player has been eliminated
			PassOn(Event);
		}
		default: {
			// Not used events
			Discard(Event);
		}
	}
}
***

***EndRound***
***
// End round
StartTime = -1;
Score::RoundEnd();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
***

***EndMap***
***
// End match
Score::MatchEnd();
***


/****************************************
	FUNCTIONS
****************************************/

// Spawn the given player
Void MySpawnPlayer(CSmPlayer _Player) {
	// Find a spawn block for the player
	declare SpawnIds = G_ClanSpawnIds[_Player.RequestedClan];
	declare SpawnId = SpawnIds[MathLib::Rand(0, SpawnIds.count-1)];
	declare Spawn <=> BlockSpawns[SpawnId];
	
	// Spawn the player in its desired team
	SM::SpawnPlayer(_Player, _Player.RequestedClan, Spawn, StartTime);
}

// Load and prepare map for the match
Void PrepareMap() {
	// Turn lights on
	foreach (Base in Bases) {
		Base.IsActive = True;
		Base.Clan = 0;
	}
	
	// Save team spawns
	G_ClanSpawnIds.clear();
	foreach (Spawn in BlockSpawns) {
		if (Spawn.Order != 1 && Spawn.Order != 2) {
			// No team spawn
			continue;
		}
		
		if (!G_ClanSpawnIds.existskey(Spawn.Order)) {
			// Init spawns array
			G_ClanSpawnIds[Spawn.Order] = Ident[];
		}
		
		// Save spawn id in array of its order
		G_ClanSpawnIds[Spawn.Order].add(Spawn.Id);
	}
	
	// Save bomb spots
	G_BombPoleIds.clear();
	foreach (Pole in BlockPoles) {
		if (Pole.Tag != "A" && Pole.Tag != "B" && Pole.Tag != "C") {
			// No bomb spot
			continue;
		}
		
		// Add pole to bomb spots
		G_BombPoleIds.add(Pole.Id);
	}
	
	// Reset attacking team
	G_AttackingTeam = -1;
}

// Prepare next round
Void PrepareRound() {
	// Despawn all players
	SM::UnspawnAllPlayers();
	
	declare SwitchSides = True;
	
	if (G_AttackingTeam < 0) {
		// Pick randomly which team starts attacking first
		G_AttackingTeam = MathLib::Rand(1, 2);
		
		if (G_AttackingTeam == 1) {
			// The spawns are fine like that - No need to switch sides
			SwitchSides = False;
		}
	} else {
		// Switch attacking team
		G_AttackingTeam = 3 - G_AttackingTeam;
	}
	
	if (SwitchSides) {
		// The teams are switching sides! - Switch spawn arrays
		declare Temp = G_ClanSpawnIds[1];
		G_ClanSpawnIds[1] = G_ClanSpawnIds[2];
		G_ClanSpawnIds[2] = Temp;
	}
	
	// Prepare spawns
	foreach (Order => SpawnIds in G_ClanSpawnIds) {
		foreach (SpawnId in SpawnIds) {
			declare Spawn <=> BlockSpawns[SpawnId];
			
			// Set team color
			Spawn.Base.Clan = Order;
		}
	}
	
	// Prepare poles
	foreach (PoleId in G_BombPoleIds) {
		declare Pole <=> BlockPoles[PoleId];
		
		// Set team color
		Pole.Base.Clan = G_AttackingTeam;
		Pole.Gauge.Clan = G_AttackingTeam;
		
		// Reset capture progress
		Pole.Gauge.ValueReal = 0.;
	}
}
